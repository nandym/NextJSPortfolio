import React, { useRef, useEffect, useState, createRef } from 'react';
//import { asciiChars } from '../constants/pixel-ascii';
import { calculateAndSetFontSize, canvasImgToUrl, getAsciiFromImage, getAsciiFromImageColor, lineHeight, lineSpacing, } from '../canvas-handler/image-canvas-ascii';
export var ArtTypeEnum;
const asciiChars = ' .,:;i1tfcLCXO0W@';
(function (ArtTypeEnum) {
    ArtTypeEnum["ASCII"] = "ASCII";
    ArtTypeEnum["ASCII_COLOR"] = "ASCII_COLOR";
    ArtTypeEnum["ASCII_COLOR_BG_IMAGE"] = "ASCII_COLOR_BG_IMAGE";
})(ArtTypeEnum || (ArtTypeEnum = {}));
const defaultProps = {
    preTagRef: createRef(),
    flipY: false,
};
export const ImageAscii = (props) => {
    // Merge the props with the default props
    const mergedProps = { ...defaultProps, ...props };
    // Set the local variables
    const canvasVideoBufferRef = useRef(null);
    const [asciiText, setAsciiText] = useState('');
    // UseEffect to calculate the font size and set the resize observer (to resize the canvas and the font size, when the parent element is resized)
    useEffect(() => {
        calculateAndSetFontSize(mergedProps.preTagRef.current, mergedProps.charsPerLine, mergedProps.charsPerColumn, mergedProps.parentRef.current.clientWidth, mergedProps.parentRef.current.clientHeight);
        // Set a resize observer to the parent element to resize the canvas and the font size
        const resizeObserver = new ResizeObserver(entries => {
            const { width, height } = entries[0].contentRect;
            calculateAndSetFontSize(mergedProps.preTagRef.current, mergedProps.charsPerLine, mergedProps.charsPerColumn, width, height);
        });
        if (mergedProps.parentRef.current) {
            resizeObserver.observe(mergedProps.parentRef.current);
        }
        drawAsciiArt();
        // Stop the resize observer when the component is unmounted
        return () => {
            resizeObserver.disconnect();
        };
    }, [mergedProps.image, mergedProps.parentRef, mergedProps.charsPerLine, mergedProps.charsPerColumn, mergedProps.artType]);
    const drawAsciiArt = () => {
        const canvas = canvasVideoBufferRef.current;
        const context = canvas.getContext('2d', { willReadFrequently: true });
        context.drawImage(mergedProps.image, 0, 0, canvas.width, canvas.height);
        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
        switch (mergedProps.artType) {
            case ArtTypeEnum.ASCII:
                setAsciiText(getAsciiFromImage(imageData, asciiChars));
                break;
            case ArtTypeEnum.ASCII_COLOR:
                setAsciiText(getAsciiFromImageColor(imageData, asciiChars));
                break;
            case ArtTypeEnum.ASCII_COLOR_BG_IMAGE:
                setAsciiText(getAsciiFromImage(imageData, asciiChars));
                // Set the background image of the pre tag to the resized canvas
                mergedProps.preTagRef.current.style.backgroundImage = `url(${canvasImgToUrl(canvas).src})`;
                // // Set the background image of the pre tag to the original dimensions video
                // mergedmergedProps.preTagRef.current!.style.backgroundImage = `url(${videoImgToUrl(mergedProps.videoStreaming).src})`;
                break;
            default:
                break;
        }
    };
    return (React.createElement("div", { style: {
            backgroundColor: mergedProps.backgroundColor,
            padding: 0, margin: 0, display: 'flex', justifyContent: 'center',
            alignItems: 'center', width: '100%', height: '100%',
        } },
        React.createElement("canvas", { ref: canvasVideoBufferRef, width: mergedProps.charsPerLine, height: mergedProps.charsPerColumn, style: { display: 'none' } }),
        (() => {
            switch (mergedProps.artType) {
                case ArtTypeEnum.ASCII:
                    return (React.createElement("pre", { ref: mergedProps.preTagRef, style: {
                            backgroundColor: mergedProps.backgroundColor,
                            color: mergedProps.fontColor,
                            padding: 0,
                            margin: 0,
                            letterSpacing: `${lineSpacing}em`,
                            lineHeight: `${lineHeight}em`,
                            transform: `scaleX(${mergedProps.flipY ? -1 : 1})`,
                            overflow: 'hidden',
                        } }, asciiText));
                case ArtTypeEnum.ASCII_COLOR:
                    return (React.createElement("pre", { ref: mergedProps.preTagRef, dangerouslySetInnerHTML: { __html: asciiText }, style: {
                            backgroundColor: mergedProps.backgroundColor,
                            color: mergedProps.fontColor,
                            padding: 0,
                            margin: 0,
                            letterSpacing: `${lineSpacing}em`,
                            lineHeight: `${lineHeight}em`,
                            transform: `scaleX(${mergedProps.flipY ? -1 : 1})`,
                            overflow: 'hidden',
                        } }));
                case ArtTypeEnum.ASCII_COLOR_BG_IMAGE:
                    return (React.createElement("span", null,
                        React.createElement("pre", { ref: mergedProps.preTagRef, style: {
                                padding: 0,
                                margin: 0,
                                letterSpacing: `${lineSpacing}em`,
                                lineHeight: `${lineHeight}em`,
                                backgroundSize: '100% 100%',
                                backgroundClip: 'text',
                                WebkitBackgroundClip: 'text',
                                color: 'transparent',
                                transform: `scaleX(${mergedProps.flipY ? -1 : 1})`,
                                overflow: 'hidden',
                            } }, asciiText)));
                default:
                    return (React.createElement("p", null, "ERROR"));
            }
        })()));
};
//# sourceMappingURL=ImageAscii.js.map